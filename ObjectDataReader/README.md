# ObjectDataReader
## Requires
- Visual Studio 2013
## License
- Apache License, Version 2.0
## Technologies
- SQL Server
- ADO.NET Entity Framework
- ADO.NET
- Entity Framework
## Topics
- Performance
## Updated
- 06/11/2014
## Description

<div class="WikiContent"><span id="ctl00_ctl00_Content_TabContentPanel_Content_wikiSourceLabel">
<div class="wikidoc"><strong>Resource Page Description</strong></div>
<div class="wikidoc"><strong></strong><br>
An IDataReader implementation that reads a collecion of entities to enable using SqlbulkCopy with LINQ.
<br>
<br>
<br>
This simple class wraps a collection of CLR objects (IEnumerable&lt;T&gt;) and exposes the collection as an IDataReader. This is usefull for using SqlBulkCopy with collections of entities, especially entities generated by LINQ to SQL and Entity Framework.<br>
<br>
For instance, here's a snippet of code that creates a collection of entity objects and uses SqlBulkCopy to load them into a SQL Server table.<br>
<br>
Notice the AsDataReader extension method that transforms the entity collection into an IDataReader.<br>
<br>
</div>
<div class="wikidoc">
<pre>    static int SendOrders(int totalToSend)
    {
      using (SqlConnection con = new SqlConnection(connectionString))
      {
        con.Open();
        using (SqlTransaction tran = con.BeginTransaction())
        {
          var newOrders =
                  from i in Enumerable.Range(0, totalToSend)
                  select new Order
                  {
                    customer_name = &quot;Customer &quot; &#43; i % 100,
                    quantity = i % 9,
                    order_id = i,
                    order_entry_date = DateTime.Now
                  };
 
          SqlBulkCopy bc = new SqlBulkCopy(con,
            SqlBulkCopyOptions.CheckConstraints |
            SqlBulkCopyOptions.FireTriggers |
            SqlBulkCopyOptions.KeepNulls, tran);
 
          bc.BatchSize = 1000;
          bc.DestinationTableName = &quot;order_queue&quot;;
          bc.WriteToServer(newOrders.AsDataReader()); 
 
          tran.Commit();
        }
        con.Close();
 
      }
 
      return totalToSend;
 
    }
 
</pre>
<br>
Also can be used to load a DataTable from an IEnumerable&lt;T&gt;, like this<br>
<br>
<pre>    static void Main(string[] args)
    {
      using (var db = new testDataContext())
      {
        var q = from o in db.sales_facts
                select o;
 
        DataTable t = q.ToDataTable();
        
 
        t.WriteXml(Console.Out);
      }
      Console.ReadKey();
    }
  }
</pre>
<br>
The EntityDataReader wraps a collection of CLR objects in a DbDataReader. Only &quot;scalar&quot; properties are projected. This is useful for doing high-speed data loads with SqlBulkCopy, and copying collections of entities ot a DataTable for use with SQL Server Table-Valued
 parameters, or for interop with older ADO.NET applciations.<br>
<br>
For explicit control over the fields projected by the DataReader, just wrap your collection of entities in a anonymous type projection before wrapping it in an EntityDataReader.<br>
<br>
For explicit mapping, instead of <br>
<pre>      IEnumerable&lt;Order&gt; orders;
      ...
      IDataReader dr = orders.AsDataReader();
      
 
</pre>
do<br>
<pre>      IEnumerable&lt;Order&gt; orders;
      ...
      var q = from o in orders
              select new 
              {
                 ID=o.ID,
                 ShipDate=o.ShipDate,
                 ProductName=o.Product.Name,
                 ...
              }
      IDataReader dr = q.AsDataReader();
 
</pre>
<br>
The EntityDataReader now uses dynamic methods to access the properties on your collection of objects, providing dramatically improved performance over using Reflection for property accessors. Common CLR scalar types and nullable value types are all enabled
 for dynamic method access. <br>
<br>
Here's a simple example of using the DataReader to pass a collection to a SQL Server Table-Valued Parameter (TVP). This just passes a list of integers, but you could pass a full collection of entities the same way.<br>
<br>
<pre>        using (SqlConnection con = new SqlConnection(&quot;Data Source=(local);Database=AdventureWorks;Integrated Security=true&quot;))
        {
          con.Open();
 
          SqlCommand cmd = new SqlCommand(
              @&quot;select max(LineTotal) 
              from Sales.SalesOrderDetail 
              where SalesOrderId in (select Value from @ids)&quot;, con);
          SqlParameter pIds = cmd.Parameters.Add(new SqlParameter(&quot;@ids&quot;, SqlDbType.Structured));
 
          //created with this DDL: CREATE TYPE Int_TableType AS TABLE(Value int NOT NULL)
          pIds.TypeName = &quot;Int_TableType&quot;;
 
          //create a list of ID's
          var ids = Enumerable.Range(43659, 1000);
          pIds.Value = ids.AsDataReader();
 
          object val = cmd.ExecuteScalar();
 
          Console.WriteLine(val);
        }
</pre>
<br>
Here's another TVP sample, this time using a multi-column TVP to pass a collection of entities to SQL 2008 and MERGE them into a table.<br>
<br>
<pre>      using (var db = new AdventureWorksContextDataContext())
      using (var con = db.Connection)
      {
        //db.ObjectTrackingEnabled = false;
        var lo = new <a class="libraryLink" href="http://msdn.microsoft.com/en-US/library/System.Data.Linq.DataLoadOptions.aspx" target="_blank" title="Auto generated link to System.Data.Linq.DataLoadOptions">System.Data.Linq.DataLoadOptions</a>();
        lo.LoadWith&lt;SalesOrderHeader&gt;(o =&gt; o.SalesOrderDetail );
        db.LoadOptions = lo;
        db.Connection.Open();
 
        var customerId = (from o in db.SalesOrderHeaders
                          where o.SalesOrderDetails.Count() &gt; 2
                          select o).Take(1).First().CustomerID;
              
        
        var q = from o in db.SalesOrderHeaders
                where o.CustomerID == customerId
                select o;
 
        var orders = q.ToList();
 
        foreach (var o in orders)
        {
          foreach (var od in o.SalesOrderDetails)
          {
            od.UnitPrice = od.UnitPrice * 1.04M;
          }
        }
 
        string sql = @&quot;
declare @output Sales_SalesOrderDetail_type
 
MERGE Sales.SalesOrderDetail AS target
USING 
( 
  SELECT
    SalesOrderID,
    SalesOrderDetailID,
    UnitPrice
  FROM @OrderDetails 
) AS source (SalesOrderID, SalesOrderDetailID, UnitPrice)
ON 
(
      target.SalesOrderID = source.SalesOrderID
  and target.SalesOrderDetailID = source.SalesOrderDetailID
)
WHEN MATCHED 
    THEN UPDATE SET target.UnitPrice = source.UnitPrice, 
                    target.ModifiedDate = GETDATE()
OUTPUT inserted.*
into @output;
 
select * from @output;
&quot;;
 
        var cmd = new SqlCommand(sql, (SqlConnection)db.Connection);
        var pOrderDetails = cmd.Parameters.Add(new SqlParameter(&quot;@OrderDetails&quot;, SqlDbType.Structured));
        pOrderDetails.TypeName = &quot;Sales_SalesOrderDetail_type&quot;;
        
        /*
        CREATE TYPE Sales_SalesOrderDetail_type as TABLE
        (
	        [SalesOrderID] [int] NOT NULL,
	        [SalesOrderDetailID] [int]  NOT NULL,
	        [CarrierTrackingNumber] [nvarchar](25) NULL,
	        [OrderQty] [smallint] NOT NULL,
	        [ProductID] [int] NOT NULL,
	        [SpecialOfferID] [int] NOT NULL,
	        [UnitPrice] [money] NOT NULL,
	        [UnitPriceDiscount] [money] NOT NULL,
	        [LineTotal]  MONEY,
	        [rowguid] [uniqueidentifier] ROWGUIDCOL  NOT NULL,
	        [ModifiedDate] [datetime] NOT NULL
        ) 
       */
        //project the results into an Anonymous type matching the TVP declaration
        var dtq = from od in orders.SelectMany(o =&gt; o.SalesOrderDetails).Take(1000)
                  select new 
                  {
                    SalesOrderID = od.SalesOrderID,
                    SalesOrderDetailId = od.SalesOrderDetailID,
                    CarrierTrackingNumber = od.CarrierTrackingNumber,
                    OrderQty = od.OrderQty,
                    ProductID = od.ProductID,
                    SpecialOfferID = od.SpecialOfferID,
                    UnitPrice = od.UnitPrice,
                    UnitPriceDiscount = od.UnitPriceDiscount,
                    LineTotal = od.LineTotal,
                    rowguid = od.rowguid,
                    ModifiedDate = od.ModifiedDate
                  };
 
        var i = 0;
 
        var f = new { a = i&#43;&#43;, b = i&#43;&#43;, c = i&#43;&#43; };
 
        //wrap the collection in a DataReader for sending to the server
        pOrderDetails.Value = dtq.AsDataReader();
 
        IList&lt;L2S.SalesOrderDetail&gt; results;
        using (var dr = cmd.ExecuteReader())
        {
          results = db.Translate&lt;L2S.SalesOrderDetail&gt;(dr).ToList();
        }
 
        
        foreach (var r in results)
        {
          Console.WriteLine(&quot;{0} {1}&quot;,r.SalesOrderDetailID,r.UnitPrice);
 
        }
 
        if (dtq.Count() != results.Count())
        {
          throw new InvalidOperationException(&quot;Wrong number of rows affected by MERGE&quot;);
        }
      }
</pre>
<br>
<br>
David<br>
dbrowne@microsoft.com</div>
</span></div>
